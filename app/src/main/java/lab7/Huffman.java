/*
 * This source file was generated by the Gradle 'init' task
 */
package lab7;

import java.util.PriorityQueue;
import java.io.FileNotFoundException;
import java.io.File;
import java.util.Scanner;
import java.util.HashMap;
import heap.Heap;

public class Huffman {
    public static void main(String[] args) {
        
        if (args.length < 1) {
            System.out.println("specify a file to read");
            return;
        }

        String filename = args[0];
        StringBuilder textBuilder = new StringBuilder();

        // Scan file
        try {
          File file = new File(filename);
          Scanner scanboy = new Scanner(file);
          // Save as text
          while (scanboy.hasNextLine()) {
            textBuilder.append(scanboy.nextLine());
          }

          scanboy.close();
        } catch (FileNotFoundException e) {
          System.out.println("File not found: " + filename);
          return;
        } 

        String text = textBuilder.toString();
        //variables
        HashMap<Character, Integer> frequencies = new HashMap<>(); //(char, frequency)
        PriorityQueue<Node> forest = new PriorityQueue<>((a,b) -> a.frequency - b.frequency); //(char, frequency. comparator maintains ascending order by frequency) 


        //save text frequencies in hashmap
        for (char c : text.toCharArray()) {
            //if key c has no instances, returns 0 instead of 'null'
            frequencies.put(c, frequencies.getOrDefault(c,0) + 1);
        }
        //create priority queue from hashmap
        for (char c : frequencies.keySet()) {
            forest.add(new Node(c, frequencies.get(c)));
        }

        //PRINT FREQUENCY MAP FOR DEBUGGING
        System.out.println("\nFrequency Table:");
        System.out.println(frequencies);
        

        //merge forest Nodes into a tree
        while (forest.size() > 1) {
            //variables
            Node left = forest.poll();  
            Node right = forest.poll();
            Node newNode = new Node('\0', left.frequency + right.frequency);

            //assign children
            newNode.left = left;
            newNode.right = right;

            //add newNode back to priorityQueue
            forest.add(newNode);
        }

        //root of tree is only node left in queue
        Node root = forest.poll();

        printResults(text, root);
    }

    /* Helper method to print results */
    private static void printResults(String text, Node root){
        //PRINT RESULTS
        StringBuilder encodedString = new StringBuilder();
        HashMap<Character, String> codeMap = new HashMap<>();
        encodeToMap(root, encodedString, codeMap);

        String encoded = encode(text, codeMap);
        String decoded = decode(encoded, root);
        //PRINT MAP FOR DEBUGGING
        // System.out.println("\nString as map: " + codeMap);

        System.out.println("\nInput string: " + text);
        System.out.println("Encoded string: " + encoded);
        if (text.length() < 100){System.out.println("Decoded string: " + decode(encode(text, codeMap), root));}

        // Boolean check
        System.out.println(text.equals(decoded));
        // Compression ratio
        double compressionRatio = (double) encoded.length() / (text.length() * 8.0);
        System.out.println(compressionRatio);
    }

    /* Helper method to encode nodes into a hashmap using a stringbuilder and recursion*/
    private static void encodeToMap(Node root, StringBuilder str, HashMap codeMap){
        //if leaf, print the string and add it to hashmap
        if (root.character != '\0'){
            codeMap.put(root.character, str.toString());
        }

        //recursively traverse and add numbers
        if (root.left != null){
            encodeToMap(root.left, str.append('0'), codeMap);
            str.deleteCharAt(str.length()-1);
        }
        if (root.right != null){
            encodeToMap(root.right, str.append('1'), codeMap);
            str.deleteCharAt(str.length()-1);
        }
    }

    /* Helper method to encode a string and return it */
    //TO DO: change to string builder instead of concatonation
    private static String encode(String string, HashMap encoder){
        String newText = "";
        for (char c : string.toCharArray()){{newText += encoder.get(c);}}
        return newText;
    }

    /* Helper method to decode a string and return it */
    //TO DO: change to string builder instead of concatonation
    private static String decode(String string, Node root){
        String newText = "";
        Node cur = root;

        //for each number
        for(int i = 0; i < string.length(); i++){

            //move left or right
            if (string.charAt(i) == '0'){cur = cur.left;} 
            else {cur = cur.right;}

            //if leaf, add character
            if (cur.left == null && cur.right == null){
                newText += cur.character;
                cur = root;
            }
        }
        return newText;
    }
}

/* Node class with:
    char
    frequency
    left/right Nodes
    */
class Node {
    char character;
    int frequency;
    Node left;
    Node right;

    //constructor for Nodes
    Node(char character, int frequency){
        this.character = character;
        this.frequency = frequency;
        left = null;
        right = null;
    }
}
